\documentclass[12pt, spanish, oneside, onecolumn, a4paper]{report}
\usepackage[spanish,activeacute]{babel}
\usepackage[latin1,utf8]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}
\usefont{T1}{arial}{m}{n}
\oddsidemargin 0in
\textwidth 6.75in
\topmargin 0in
\textheight 8.5in
% \parindent 0em
\parskip 2ex

\usepackage{fancyheadings}
\headheight 35pt
\usepackage{graphicx}
\usepackage[colorlinks=true, urlcolor=blue, filecolor=green,
linkcolor=red, pdfkeywords={}, pagebackref, pdfpagemode=UseOutlines,
bookmarksopen=true]{hyperref}

\usepackage{tabularx}
\usepackage{colortbl}
\usepackage{wrapfig}

\usepackage{tabulary}
\setlength\tymin{699pt}
\setlength\tymax{700pt}
\setlength\doublerulesep{0.5px}

\graphicspath{{./img/}}

\usepackage{epic}
\makeatletter

\renewcommand{\contentsname}{Indice}
\renewcommand{\appendixname}{Apéndice}
\renewcommand{\figurename}{Figura}
\renewcommand{\listfigurename}{Indice de figuras}
\renewcommand{\tablename}{Tabla}
\renewcommand{\listtablename}{Indice de tablas}

% un comando
\def\comando#1{

\begin{tabulary}{620px}{|>{\columncolor[rgb]{0.8,0.9,0.8}}L|}
  \hline \textsl{#1}\ \hline
\end{tabulary}

}

% varios comandos
\newenvironment{command} {

  \tabulary{420px}{*{2}{|>{\columncolor[rgb]{0.8,0.9,0.8}}L}|}
  % \hline
  \textbf{portage:} & \textbf{entropy:}\tabularnewline } {
  % \hline
  \endtabulary

}
% end comandos

\usepackage[toc,nonumberlist]{glossaries}
\makeglossaries

%\begin{titlepage}
%\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here
%\center % Center everything on the page
%
%%\textsc{\LARGE University Name}\\[1.5cm] % Name of your university/college
%%\textsc{\Large Major Heading}\\[0.5cm] % Major heading such as course name
%%\textsc{\large Minor Heading}\\[0.5cm] % Minor heading such as course title
%\HRule \\[0.4cm]
%{ \huge \bfseries Git}\\[0.4cm] % Title of your document
%\HRule \\[1.5cm]
%\begin{minipage}{0.4\textwidth}
%\begin{flushleft} \large
%\emph{Author:}\\
%Ing. Anielkis \textsc{Herrera} % Your name
%\end{flushleft}
%\end{minipage}
%~
%\begin{minipage}{0.4\textwidth}
%\begin{flushright} \large
%%\emph{Supervisor:} \\
%%Dr. James \textsc{Smith} % Supervisor's Name
%\end{flushright}
%\end{minipage}\\[4cm]
%{\large \today}\\[3cm] % Date, change the \today to a set date if you want to be precise
%%\includegraphics{Logo}\\[1cm] % Include a department/university logo - this will require the graphicx package
%\vfill % Fill the rest of the page with whitespace
%\end{titlepage}

\makeatletter
\def\maketitle{%
  \null
  \thispagestyle{empty}%
  \vfill
  \begin{center}\leavevmode
    \normalfont
    \includegraphics{logo.png}\\[1cm]
%    {\LARGE \@title\par}%
    \vskip 1cm
    {\Large \@author\par}%
    \vskip 1cm
    {\Large \@date\par}%
  \end{center}%
  \vfill
  \null
  \cleardoublepage
  }
\makeatother


\begin{document}
\pagestyle{fancy}
\lhead{\includegraphics[width=3cm,keepaspectratio=true]{logo.png}
%\includegraphics[width=3cm,keepaspectratio=true]{emblema-2008.eps}
}
%\cfoot{ \itshape{Carretera a San Antonio de los Baños. Km 5 {1/2}
% Reparto Torrens. Boyeros. Ciudad Habana.  Teléfono (53 7) 8372519
% e-mail: decano.f10@uci.cu }\newline \thepage}

\title{ Git }
\date{ \today\ }
\author{ Ing. Anielkis Herrera }

\pagenumbering{roman}
\maketitle

%\begin{abstract}
%Guía de uso de la herramienta Git para control de versiones
%\end{abstract}

\newpage
\pagenumbering{arabic}


\chapter{Introducción a Git}
\label{chap:intro}


\newacronym[longplural=Sistemas de Control de Versiones]{scv}{SCV}{Sistema de Control de Versiones}
\newacronym[longplural=Sistemas de Control de Versiones Distribuido]{scvd}{SCVD}{Sistema de Control de Versiones Distribuido}

%\newglossaryentry{scv}
%{
%  description={Sistema de Control de Versiones, sistemas utilizados para gestionar versionado en el desarrollo de software o documentación}
%}

%\newglossaryentry{Linux}
%{
%  description={es un término genérico que se refiere a la familia de sistemas operativos ``parecidos a Unix'' que utilizan el núcleo Linux}
%}

Git es un \gls{scvd}, desarrollado como sistema de software libre y diseñado para manejar desde proyectos pequeños hasta muy grandes, con gran rapidez y eficiencia.

Git es fácil de aprender y tiene una huella pequeña en el sistema, con un rendimiento increíblemente rápido. Supera a otros \glspl{scv} como Subversion , CVS , Perforce y ClearCase con características como trabajo con ramas locales, áreas de ``puesta en escena'' muy convenientes, y varios estilos de flujo de trabajo.


\section{Acerca de Git}
\label{sec:aboutgit}

\subsection{Creación y fusión de ramas}
\label{sec:branchingandmerging}

La función de Git que realmente lo hace destacar de entre la mayoría de los \gls{scv} es su modelo de ramificación. Git permite y alienta a tener varias ramas locales que pueden ser completamente independientes una de otra. La creación, fusión y supresión de las líneas de desarrollo toma solo unos instantes de segundo.

Esto significa que se pueden hacer cosas como:
\begin{description}
\item [Cambio de contexto sin fricción:] crear una rama para probar una idea,
adicionar contenido al historial un par de veces, volver a la rama desde donde se ramificó, aplicar un
parche, cambiar de nuevo a donde se está experimentando, y fusionar las ramas para adicionar los cambios del experimento a la rama original.
\item [Líneas de desarrollo separadas en roles:] tener una rama que siempre contiene sólo lo que va a la producción, otra a dónde se fusionan el código en que se ha trabajado, para probarlo, y varios más pequeños para el día a día.
\item [Función de flujo de base:] crear nuevas ramas para cada nueva característica en que se esté trabajando por lo que perfectamente puede alternar entre ellas, y a continuación eliminar cada rama cuando esta característica se fusione en la línea principal.
\item [Experimentación desechable:] crear una rama en la que experimentar , darse cuenta de que no va funcionar el experimento, y simplemente eliminarla - el abandono de un trabajo fallido que nadie más va a ver.
\end{description}

\begin{figure}[hb]
  \caption{Ramas en Git.}
  \centering
  \includegraphics[width=.7\textwidth,keepaspectratio=true]{branches.png}
\end{figure}

En particular, cuando se ``empuja'' (\emph{\textbf{push}}) a un repositorio remoto, no es necesario hacerlo a todas las ramas. Se puede elegir compartir sólo una de las ramas, unas pocas de ellas o todas ellas. Esto permite probar nuevas ideas sin preocuparse de tener que planificar cómo y cuándo se va a fusionar o compartirlas con otros. Como se podrá ver posteriormente, se puede compartir la rama con otro desarrollador, con el que se puede trabajar en esa idea, sin necesidad de adicionarla al repositorio central.

Hay maneras de lograr algo de esto con otros sistemas, pero la obra en cuestión es mucho más difícil y propensa a errores. Git hace este proceso muy fácil y esto cambia la forma en la mayoría de los desarrolladores trabajan cuando lo aprenden.


\subsection{Pequeño y rápido}
\label{sec:smallandfast}

Git es rápido. Con Git, practicamente todas las operaciones son realizadas localmente, dandole una gran ventaja sobre los \gls{scv} centralizados que constantemente tienen que comunicarse con el servidor.

Git fue hecho para trabajar con el núcleo Linux, lo que sifnifica que tiene que trabajar eficientemente con repositorios de código muy grandes desde el primer día. Git está escrito en \textbf{C}, reduciendo la carga de ejecución asociada a lenguajes de alto nivel. La velocidad y el rendimiento son algunos de los principios seguidos desde los inicios de su diseño.

\subsection{Distribuido}
\label{sec:distributed}

Una de las mejores características de cualquier \gls{scvd}, Git incluído, es que es precisamente ``distribuido''. Esto significa que en lugar de hacer un ``checkout'' de la punta actual del código fuente, se hace un ``clon'' de todo el repositorio.

\subsubsection{Múltiples copias de seguridad}
\label{sec:multiplebackups}

Esto significa que aún si se utiliza un flujo de trabajo centralizado, cada usuario es esencialmente una copia de seguridad del servidor principal. Cada una de estas copias puede ser utilizada para sustituir el servidor central en caso de fallo o corrupción. En efecto, no hay un solo punto de fallo utilizando Git, a no ser que sólo se use una copia del repositorio.

\clearpage
\subsubsection{Cualquier flujo de trabajo}
\label{sec:anyworkflow}

Debido a la naturaleza distribuida de Git y un magnífico sistema de ramificación, un número casi infinito de flujos de trabajo se puede implementar con relativa facilidad.



\paragraph{Flujo de trabajo estilo Subversion:}


\begin{wrapfigure}{r}{0.65\textwidth}
  \begin{center}
    \includegraphics[width=.6\textwidth,keepaspectratio=true]{workflow-a.png}
  \end{center}
  \caption{Modelo centralizado estilo Subversion.}
\end{wrapfigure}
Un flujo de trabajo centralizado es bastante común, especialmente para personas cambiando desde sistemas centralizados. Git no permite que se ``empuje''(hacer \textbf{\emph{push}}) al servidor si alguien lo ha hecho desde la última vez que se descargó de él, por lo que un modelo centralizado donde todos los desarrolladores hacen \textbf{\emph{push}} al mismo servidor funciona bien.

% \begin{figure}[hb]
%   \caption{Modelo centralizado estilo Subversion.}
%   \centering
%   \includegraphics[width=.6\textwidth,keepaspectratio=true]{workflow-a.png}
% \end{figure}

\paragraph{Flujo con gerente integrador:}


\begin{wrapfigure}{r}{0.65\textwidth}
  \begin{center}
  \includegraphics[width=.6\textwidth,keepaspectratio=true]{workflow-b.png}
  \end{center}
  \caption{Modelo con gerente integrador.}
\end{wrapfigure}
Otro flujo de trabajo, común en Git, consiste en un gestor de integración - una sola persona que es quien puede adicionar al repositorio ``bendecido''(el \emph{repositorio principal del sistema}). Un número de desarrolladores luego de clonar ese repositorio, empujan a sus propios repositorios independientes , y piden al integrador que revise y fusione sus cambios a ese repositorio. Este es el tipo de modelo de desarrollo visto a menudo con software libre o repositorios en \textbf{Github}.


%\begin{figure}[hb]
%  \caption{Modelo centralizado estilo Subversion.}
%  \centering
%\end{figure}

\paragraph{Flujo basado en un dictador y sus lugartenientes:}



\begin{wrapfigure}{r}{0.65\textwidth}
  \begin{center}
  \includegraphics[width=.6\textwidth,keepaspectratio=true]{workflow-c.png}
  \end{center}
  \caption{Modelo con dictador y lugartenientes.}
\end{wrapfigure}
Para proyectos más grandes, un flujo de trabajo de desarrollo como el del núcleo Linux es a menudo eficaz. En este modelo, algunas
personas ( ``lugartenientes'' ) están a cargo de un subsistema específico del proyecto y fusionan todos los cambios relacionados con ese subsistema. Otra integrador (el ``dictador'' ) puede extraer los cambios sólo de sus lugartenientes (luego que estos los revisaron e integraron a sus subsistemas) y luego empujar al repositorio ``bendecido'' de dónde todo el mundo usa para trabajar.


% \begin{figure}[hb]
%   \caption{Modelo centralizado estilo Subversion.}
%   \centering
%   \includegraphics[width=.6\textwidth,keepaspectratio=true]{workflow-c.png}
% \end{figure}


\clearpage

\subsection{Seguridad de los datos}
\label{sec:dataassurance}


El modelo de datos que usa Git garantiza la integridad criptográfica de cada parte de su proyecto. A cada archivo y revisión en el historial se le realiza una suma de comprobación (suma de chequeo) y es recuperado por medio de su suma de chequeo al recrear el directorio. Por esto es imposible sacar nada de Git que no sean los bits exactos que se le ponen dentro.


\begin{wrapfigure}{r}{0.65\textwidth}
  \begin{center}
  \includegraphics[width=.6\textwidth,keepaspectratio=true]{assurance.png}
  \end{center}
  \caption{Sumas de chequeo.}
\end{wrapfigure}


También es imposible cambiar cualquier archivo, la fecha, el mensaje con que se adicionó al historial, o cualquier otro dato en un repositorio Git sin cambiar los identificadores de todo lo que ocurrió después de adicionarlo. Esto significa que si usted tiene un ID de un ``\textbf{commit}'' (una revisión), puede estar seguro no sólo de que el proyecto es exactamente el mismo que cuando se adicionó, sino que nada en su historial cambió.

La mayoría de los \gls{scv} centralizados no proveen esta integridad de forma predeterminada.

\clearpage
\subsection{Zona de espera}
\label{sec:stagingarea}

\begin{wrapfigure}{r}{0.65\textwidth}
  \begin{center}
  \includegraphics[width=.6\textwidth,keepaspectratio=true]{index1.png}
  \end{center}
  \caption{Zona de espera.}
\end{wrapfigure}


A diferencia de los otros sistemas, Git tiene algo que se llama la ``zona de espera'' o ``índice''. Esta es una zona intermedia en la que los \textbf{\emph{commits}} pueden ser formateados y o revisados antes de terminar de adicionarlos como una revisión en el historial.

Una cosa que distingue a Git de otras herramientas es que es posible para organizar rápidamente las modificaciones en los archivos, sin adicionar todas las modificaciones hechas en una sola revisión en el historial.

\begin{wrapfigure}{r}{0.65\textwidth}
  \begin{center}
  \includegraphics[width=.6\textwidth,keepaspectratio=true]{index2.png}
  \end{center}
  \caption{Zona de espera.}
\end{wrapfigure}

Esto le permite poner en escena sólo partes de un archivo modificado. Atrás han quedado los días de hacer dos modificaciones lógicamente no relacionadas en uno o varios archivos, antes de darse cuenta de que se ha olvidado adicionar una de ellas al historial. Ahora se puede incluir sólo uno de cambios realizados al archivo, en una revisión y luego adicionar otro cambio en otra revisión. Esta función se puede utilizar para múltiples cambios, según sea necesario, permitiendo organizar mejor los cambios adicionados, por ejemplo, según funcionalidad o módulo.

Por supuesto, Git también puede olvidar esta funcionalidad si no se desea este tipo de control, sólo adicionando ``$-$a'' al comando, adiciona \textbf{TODOS} los cambios realizados a los archivos conocidos por Git (todos los que han sido adicionados al historial en la revisión anterior); haciendo que Git se comporte como Subversion al realizar un \textbf{commit}.


\chapter{Comenzando con Git}
\label{chap:gettingstarted}

\section{Lo esencial de Git}
\label{sec:gitbasics}

Entonces, ¿qué es Git en pocas palabras? Esta es una sección importante de absorber, porque si se entiende lo que es Git y los
fundamentos de cómo funciona, podrá utilizar Git de uan forma màs eficaz y probablemente será mucho más fácil. A medida que se aprenda Git, se debe intentar limpiar la mente de las cosas que se pueden conocer de otros \gls{scv}, tales como Subversion y Perforce , lo cual ayudará a evitar confusiones sutiles cuando se utiliza la herramienta. Git almacena información y piensa en forma muy diferente a los otros sistemas, a pesar de que la interfaz de usuario es bastante similar; entender esas diferencias ayudará a evitar que se vuelva confuso mientras se esté utilizando.

\section{Imágenes del contenido, no las diferencias}
\label{sec:snapshotsnotdifferences}


\begin{wrapfigure}{r}{0.5\textwidth}
  \begin{center}
  \includegraphics[width=.6\textwidth,keepaspectratio=true]{18333fig0104-tn.png}
  \end{center}
  \caption{Otros sistemas tienden a almacenar datos como cambios a una versión base de cada archivo.}
  \label{otrosvcs}
\end{wrapfigure}


La principal diferencia entre Git y cualquier otro \gls{scv} (Subversion y amigos incluidos) es la forma en Git piensa en sus datos. Conceptualmente, la mayoría de los otros sistemas almacena información como una lista de los cambios basados en ficheros. Estos sistemas (CVS, Subversion, Perforce , Bazaar, y así sucesivamente) pensan en la información que almacenan como un conjunto de archivos y los cambios hechos a cada fichero en el tiempo, como se ilustra en la Figure~\ref{otrosvcs}.


\begin{wrapfigure}{r}{0.65\textwidth}
  \begin{center}
  \includegraphics[width=.6\textwidth,keepaspectratio=true]{18333fig0105-tn.png}
  \end{center}
  \caption{Git almacena los datos como imágenes del proyecto a través del tiempo.}
  \label{gitsnapshot}
\end{wrapfigure}
Git no piensa ni almacene sus datos de esta forma. En su lugar, Git modela sus datos más como un conjunto de instantáneas de un mini
sistema de archivos. Cada vez que se adiciona, o guarda el estado de el proyecto en Git, básicamente se toma una fotografía de sus archivos en ese momento y almacena una referencia a esa instantánea. Para ser eficaz, si los archivos no se han modificado, Git no almacena el archivo de nuevo, sólo un enlace al archivo anterior idéntico que ya ha almacenado. Git modela sus datos más como en la Figura \href{gitsnapshot}.

Esta es una distinción importante entre Git y casi todos los otros \gls{scv}. Hace que Git reconsidere casi todos los aspectos de control de versiones que la mayoría de los otros sistemas a copiado de la generación anterior. Esto hace que Git sea más como un mini sistema de archivos con algunas herramientas increíblemente poderosas construidas en la parte superior de la misma, en lugar de simplemente un \gls{scv}. Se verán algunos de los beneficios que obtiene al pensar en sus datos de esta manera cuando se vea la ramificación en Git.
2.1.2. Casi cada operación es local
La mayoría de las operaciones en Git sólo necesitan archivos y recursos locales para operar   por lo general no se necesita información desde otro ordenador de la red. Si estás acostumbrado a un \gls{scvc} donde la mayoría de las operaciones tienen esa sobrecarga de latencia de la red, este aspecto de Git te hará pensar que los dioses de la velocidad han bendecido Git con poderes no terrenales. Porque tienes toda la historia del proyecto ah mismo en el disco local, la mayoría de las operaciones parecen casi instantánea.
Por ejemplo, para navegar por la historia del proyecto, Git no necesita salir al servidor para obtener la historia y mostrarla, sino que simplemente se lee directamente de la base de datos local. Esto significa que se ver la historia del proyecto casi al instante. Si se desea ver los cambios introducidos entre la versión actual de un archivo y el archivo de hace un mes, Git puede buscar el archivo hace un mes y hacer un cálculo de la diferencia local, en lugar de tener que pedirle a un servidor remoto la
 CAPTULO 2. COMENZANDO CON GIT información de una versión anterior del archivo, para calcularlo localmente.
Esto también significa que hay muy poco que no se pueda hacer si se está desconectado de la red o de la VPN. Si se está en un avión, o en un tren y se quiere hacer un poco de trabajo, se puede ir haciendo modificaciones, y al llegar la una conexión de red que se desea se descargan los cambios nuevos del servidor y suben los cambios realizados localmente. Si se va a casa y no logra que funcione bien el cliente VPN, usted todavía puede trabajar. En muchos otros sistemas, hacerlo as que es imposible o doloroso. En Perforce, por ejemplo , no se puede hacer mucho cuando no se está conectado al servidor, y en Subversion y CVS, se puede editar los archivos, pero no puede confirmar (hacer commit) los cambios a la base de datos (ya que su base de datos está sin conexión, en el servidor). Esto puede no parecer un gran problema, pero puede que se sorprenda la gran diferencia que puede representar.
2.1.3. Git tiene integridad
A todo en Git, se le realiza una suma de chequeo ( checksum ) y es referenciado por esa suma de chequeo. Esto significa que es imposible cambiar el contenido de un archivo o directorio sin que Git lo note. Esta funcionalidad está incluida en Git en los más bajos niveles y es parte integral de su filosofa. Por esto no se puede perder la información en tránsito o que se produzca una corrupción de los archivos sin que Git sea capaz de detectarlo.
El mecanismo que usa Git para esta suma de comprobación se llama hash SHA-1 . Es una cadena de 40 caracteres, compuesta de números hexadecimales (del 0 al 9 y de A a la F) y es calculada en base al contenido de un archivo o directorio en Git. Un  hash SHA-1  se algo como esto:
24b9da6552252987aa493b52f8696cd6d3b00373
Se verán estos valores hash por todos lados en Git, ya que los usa mucho. De hecho, Git almacena todo no por nombre de archivo, sino utilizando el valor hash de su contenido en la base de datos de Git.
2.1.4. Git generalmente sólo añade datos
Cuando se realizan acciones en Git, casi todas ellas sólo añaden datos a la base de datos de Git. Es muy difícil hacer que el sistema realice una operación que no se pueda deshacer o que borre información de alguna forma. Al igual que en cualquier \gls{scv}, se pueden perder o estropear los cambios que no se hayan adicionado a Git aún (que no se le haya hecho commit), pero después de haberle hecho commit a unos cambios, es muy difícil de que esa información no se pueda recuperar, aún más difícil si se utiliza algún servidor remoto. Llevándolo aún más lejos, cuando una revisión (un commit ) se des  hace, es quitado del historial, Git no lo borra, sino que se puede recuperar mientras no se realice una limpieza en profundidad. Esto permite que se pueda experimentar libremente, sin temor a realizar
 CAPTULO 2. COMENZANDO CON GIT un daño severo al proyecto.
2.1.5. Los tres estados
Esta es la cosa más importante a recordar acerca de Git si se quieres que el resto de su proceso de aprendizaje fluya sin problemas. Git tiene tres estados principales en que los archivos pueden residir en: commited (comprometido), modified (modificado) y staged (puesta en escena). Commited significa que los datos se almacenan de forma segura en su base de datos local. Modified significa que se ha modificado el archivo pero no lo ha hecho commit a su base de datos todavía. Y staged significa que se ha marcado un archivo modificado en su versión actual para entrar en tu próxima confirmación instantánea (próximo commit ).
Figura 2.3: Directorio de trabajo, rea de preparación y directorio Git.
Esto nos lleva a 3 secciones principales en un proyecto Git:
el directorio Git : es el repositorio local de Git donde se almacenan los metadatos y la base de datos de objetos del proyecto. Esta es la parte más importante de Git, y es lo que se copia cuando se clona un repositorio desde otro equipo.
el directorio de trabajo : es donde se encuentran los archivos de una revisión para trabajar. Estos archivos se extraen de la base de datos comprimida en el directorio Git y se coloca en el disco para que se puedan utilizar o modificar.
el área de preparación : también llamada área intermedia , rea de cache o de puesta en escena ( staging area ) es un archivo simple, generalmente dentro del directorio Git, que almacena información acerca de lo que se hará en el próximo commit . A veces se le llama  índice , pero se está convirtiendo en estándar para referirse a l como el rea de preparación .
Un flujo básico utilizando Git es algo como esto:
1. Se modifican los archivos en el directorio de trabajo .
 CAPTULO 2. COMENZANDO CON GIT 2. Se organizan los archivos o modificaciones dentro de éstos que se desean adicionar, y pasándolos al área de preparación .
3. Se hace un commit , que toma los archivos como están en el rea de preparación y almacena una instantánea permanentemente en el directorio Git, integrándola a la historia del proyecto.
Si una versión concreta de un archivo está en el directorio de Git, se considera commited . Si se ha modificado, pero se ha añadido al rea de preparación, está staged . Y si se ha sido modificado desde que fue extraído de Git y no se pasó al rea de preparación, está modified.
2.2. Instalando Git
2.2.1. Linux
Si se instar Git a través de paquetes binarios de las distribuciones, esto se realizar como con cualquier otro software:
 yum install git-core
 apt-get install git
o
 aptitude install git
2.2.2. MacOSX
Hay dos maneras fáciles de instalar Git en un Mac. La forma más fácil es usar el instalador gráfico de Git, que se puede descargar desde la página de Google Code:
http://code.google.com/p/git-osx-installer
 CAPTULO 2. COMENZANDO CON GIT Figura 2.4: Instalador de Git para OS X.
 CAPTULO 2. COMENZANDO CON GIT La otra gran manera es instalar Git a través de MacPorts ( http://www.macports.org ). Si tienes MacPorts instalado, instalar Git a través de:
 sudo port install git-core +svn +doc +bashcompletion +gitweb
No se tiene que añadir todos los extras, pero es probable que desee incluir svn, y aún más en caso de que se tenga que usar Git con repositorios de Subversion.
2.2.3. Windows
Instalar Git en Windows es muy fácil. Simplemente se descarga el archivo ejecutable de instalación desde la página de Git ( http://www.git-scm.com/ ), y se ejecuta:
 CAPTULO 2. COMENZANDO CON GIT Se deben dejar las opciones por defecto:
Figura 2.5: Se selecciona interfaz Bash (Unix) para comandos complejos
Figura 2.6: Se acepta que se cambie automáticamente el cambio de línea
Esta opción de cambiar automáticamente el cambio de línea, permite que en Windows se trabaje normalmente con los archivos (manteniendo el indicador de cambio de línea de Windows) y que al hacer commit se cambie automáticamente este indicador al de Linux. Al realizar un checkout , Git convertir los cambios de línea de Linux a Windows, para poder trabajar en ellos. Esto facilita la edición de código en ambos sistemas por parte de los desarrolladores.
 CAPTULO 2. COMENZANDO CON GIT Una vez instalado, se tiene una versión de línea de comandos (incluyendo un cliente SSH que será muy útil para acceder a los servidores) y la interfaz gráfica de usuario estándar.
Nota sobre el uso en Windows: se usar, siempre que sea posible, Git con el shell que se instala (estilo Unix), que permite utilizar las complejas líneas de comando que figuran en este documento. Si usted necesita, por alguna razón, utilizar la interfaz de comandos nativa de Windows, se deben tener otras consideraciones para hacerlo, para esto consulte la documentación de Git ( http://www. git-scm.com/doc ).
 CAPTULO 2. COMENZANDO CON GIT 2.3. Configuración inicial
2.3.1. Identidad
Los primeros pasos a realizar, es adicionar nuestros datos personales a Git; a partir de aquí, se incluirán en cada cambio que realicemos. Una información importante aquí, es que Git hace distinción, como se ver más adelante, entre los que adicionan cambios al Git y los que realizaron los cambios 1 .
Esto se realiza de esta forma:
 git configglobal user.name John Doe
 git configglobal user.email johndoeexample.com
La opción  global  especifica que estas configuraciones serán globales, las predeterminadas. Si se desea que un proyecto tenga otra identidad, solo habrá que omitir este parámetro y ejecutar los comandos dentro del directorio de trabajo.
2.4. Aspectos generales de Git
Algunas características generales de Git necesarias para comprender su funcionamiento:
En Git se utilizan varios clases de repositorio:
desnudo (bare): repositorio que solo contiene un repositorio local.
espejo (mirror): subclase de bare que también se mantiene sincronizado a los repositorios remotos al ejecutar cualquier comando que lo haga comunicarse con ellos. Este repositorio actualiza la revisiones de todas las ramas y crea nuevas en caso de ser necesario.
con directorio de trabajo: es el repositorio que contiene un repositorio local y además un directorio o copia de trabajo donde se puede modificar el contenido.
HEAD es el nombre que se le da en Git a la última revisión de una rama. Para referencias a la penúltima revisión de una rama, se puede utilizar tanto la nomenclatura HEAD1 como HEAD
1 por ejemplo, si se está aplicando un flujo de trabajo con gerente integrador y la persona A realiza un cambio realiza commit en su Git, luego envía el commit al integrador ( persona B ), el integrador revisa el commit y lo adiciona al servidor Git principal, para el servidor principal Git, el cambio lo realizó la persona A , pero lo adicionó el integrador, manteniéndose la compartimentación en los cambios
 CAPTULO 2. COMENZANDO CON GIT 2.5. Comandos básicos de Git
Figura 2.7: Operaciones principales con Git
git init: El comando init de git permite inicializar un directorio como repositorio de git, se puede utilizar de estas formas:
1. Para crear un directorio con copia de trabajo:
 cd proyecto/
 git init
 git add
 git commit
2. Para crear un repositorio desnudo:
 cd proyecto/
 git initbare
 CAPTULO 2. COMENZANDO CON GIT git clone: El comando clone en git es utilizado para clonar repositorios, creando copias de l y se puede utilizar de estas formas:
1. Para crear un directorio con copia de trabajo:
 git clone URL
2. Para crear un repositorio desnudo:
 git clone -bare URL
3. Para crear un repositorio espejo:
 git clone -mirror URL
git checkout: El comando checkout en git es utilizado para extraer objetos del repositorio local, estos objetos pueden ser archivos, directorios, ramas (branch), etiquetas (tags) o revisiones (HEAD, HEAD1). en el caso de archivos, estos se revierten a la última versión almacenada en el repositorio local. Este comando se utiliza de estas formas:
1. Para extraer la última versión de un archivo:
 git checkout
2. Para cambiar a utilizar una rama:
 git clone -bare URL
3. Para crear un repositorio espejo:
 git clone -mirror URL
  CAPTULO 3. PERSONALIZANDO GIT Capítulo 3
Personalizando Git
3.1. Configuración de Git
3.1.1. Configuración básica del cliente Git
3.1.2. Colores en Git
3.1.3. Herramientas externas para fusionar y para comparar
3.1.4. Formato y espacios en blanco
3.1.5. Configuración de Servidor
3.2. Atributos de Git
3.2.1. Archivos binarios
Identificando archivos binarios
Comparando archivos binarios
Expansión de palabras clave
Exportación del repositorio
Estrategias de fusión
3.3. Puntos de enganche Git
3.4. Un ejemplo de implantación de una determinada política en
Git
3.4.1. Punto de enganche en el lado servidor
Obligando a utilizar un formato específico en el mensaje de confirmación de cambios
Implementando un sistema de control de accesos basado en usuario
Obligando a realizar envíos solo de avance rápido (Fast Forward Only pushes)
3.4.2. Puntos de enganche del lado cliente
 Capítulo 4
Git y Subversion
4.1. Utilizando Git como cliente para servidor Subversion
Debido a su diseño modular, Git puede integrarse con otros \gls{scv}. Este nivel de integración permite tanto importar proyectos, como trabajar como cliente de otros \gls{scv}. En el caso de Subversion, esto se realiza por medio del parámetro svn adicionado al comando git , de esta forma:
 git svn
Para acceder a la ayuda y ver los comandos que se pueden utilizar, se puede ejecutar:
 git help svn
4.1.1. Haciendo svn checkout
Si el repositorio Subversion ubicado en URL cumple con el estándar de crear carpetas para desarrollo, versiones y ramas de desarrollo (trunk, tags y branches), se ejecuta:
 git svn clone -s URL
Esto crea automáticamente las ramas y los tags en Git, según están definidos en el subversion. Para especificar el nombre de los directorios, en caso de que no coincidan con los nombres en inglés, sera ejecutar esta variación del comando, especificando los nombres reales:
 git svn clone URL -T trunk -b branches -t tags
A partir de aquí se puede continuar el desarrollo utilizando Git y luego sincronizando los cambios con el Subversion, como por ejemplo, de esta forma:
 CAPTULO 4. GIT Y SUBVERSION 1. Crear una rama propia, para desarrollo:
 git checkout -b work trunk
2. Modificar y adicionar cambios al repositorio, utilizando git add y git commit según se desee.
3. Sincronizar con el servidor de subversion remoto utilizando
 git svn dcommit
Llegados a este punto, conviene brindar algunas recomendaciones:
1.
4.2. Comandos Subversion y equivalentes en Git
Pasamos a ver los comandos más utilizados en Subversion y cómo se realizara esa tarea utilizando Git:
4.2.1. Crear repositorio
subversion: git:  svnadmin create repo  git init  svn import URL  git add .  git commit git init inicializa el repositorio local, creando el directorio .git .
git add . adiciona a git todo el contenido del directorio.
git commit adiciona los cambios al historial de Git.
4.2.2. Creando la copia de trabajo
Para crear la copia o directorio de trabajo, se ejecuta: subversion: git:  svn checkout URL  git clone URL A diferencia del comando svn checkout, el de Git descarga TODO el historial del directorio subversion. Si el directorio ubicado en esa dirección cumple
 CAPTULO 4. GIT Y SUBVERSION 4.2.3. Adicionando cambios
subversion: git:  svn commit  git commit -a Aquí hay que aclarar algunas cosas:
Como se ha dicho anteriormente, el git commit adiciona cambios al repositorio local.
 Capítulo 5
Otras operaciones con Git
5.1. Buscar error en el código utilizando Git
Git, con la ayuda del comando  bisect  permite buscar por búsqueda binaria el cambio que introdujo un error. Este comando usa git rev-listbisect para ayudar al proceso de búsqueda binaria a encontrar el cambio que introdujo un error, a partir de un commit declarado como bueno, donde no exista ese error y uno malo donde se confirmó que exista.
Este proceso se puede automatizar de la siguiente forma:
1. Crear una prueba, como un script a ejecutar. Este script debe cumplir algunos requisitos:
Deber salir con código 0 si el código fuente actual es bueno, no contiene errores.
Termina con un código entre 1 y 127 (incluyendo 127), excepto 125, si el código fuente actual es defectuoso.
 cat /test.sh /bin/sh make || exit 125  evita los commits que no compilan /checktestcase.sh  ejecuta el script de verifica el error  git bisect start HEAD HEAD\~{}\~{}10 --  git bisect run /test.sh
Al ejecutar git bisect start HEAD HEAD10 se especifica que HEAD 1 es una revisión con el error y que 10 revisiones antes no lo haba ( HEAD10 ) 1 identifica al última commit realizado a la rama
 CAPTULO 5. OTRAS OPERACIONES CON GIT 5.2. Flujo de trabajo utilizando Git-Flow

















\glsaddall
\printglossaries

\end{document}
